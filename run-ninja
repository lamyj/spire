#!/usr/bin/env python

from __future__ import print_function
import argparse
import glob
import json
import os
import StringIO
import subprocess
import sys

import jinja2
import yaml

import ninja

def main():
    
    (
        arguments, jinja_arguments, 
        raw_ninja_arguments, known_ninja_arguments
    ) = parse_arguments()
    
    environment = get_jinja_environment(arguments, known_ninja_arguments)
    pipeline = parse_pipeline(arguments, jinja_arguments, environment)
    ninja_file = render_ninja(pipeline, environment)
    return run_ninja(ninja_file, raw_ninja_arguments)

def parse_arguments():
    """ Return the runner-specific, Jinja-specific and Ninja-specific (both raw
        and known) arguments parsed from the command line.
    """
    
    jinja_parser = argparse.ArgumentParser(
        description="Run Ninja from a pipeline description")
    jinja_parser.add_argument("pipeline", help="Path to pipeline description")
    jinja_parser.add_argument(
        "variables", nargs="*", 
        metavar="variable", help="Jinja variables (name=value)")
    
    main_parser = argparse.ArgumentParser(
        description="Run Ninja from a pipeline description",
        usage=jinja_parser.format_usage().strip()+" [-- ninja-option [ninja-option ...]]")
    main_parser.add_argument("pipeline", help="Path to pipeline description")
    main_parser.add_argument(
        "variables", nargs="*", 
        metavar="variable", help="Jinja variables (name=value)")
    
    if "--" in sys.argv:
        limit = sys.argv.index("--")
        arguments = main_parser.parse_args(sys.argv[1:limit])
        raw_ninja_arguments = sys.argv[1+limit:]
    else:
        arguments = main_parser.parse_args()
        raw_ninja_arguments = []
    
    try:
        jinja_arguments = {
            x.split("=", 1)[0]: x.split("=", 1)[1] 
            for x in arguments.variables}
    except Exception as e:
        main_parser.error(e)
    
    ninja_parser = argparse.ArgumentParser()
    ninja_parser.add_argument("--directory", "-C", default=os.getcwd())
    known_ninja_arguments, _ = ninja_parser.parse_known_args(raw_ninja_arguments)
    if known_ninja_arguments.directory:
        # Make sure it ends with a "/"
        known_ninja_arguments.directory = os.path.join(
            known_ninja_arguments.directory, "")
    
    return arguments, jinja_arguments, raw_ninja_arguments, known_ninja_arguments

def get_jinja_environment(arguments, known_ninja_arguments): 
    """ Return a Jinja environment which:
        * can load templates from absolute paths, from the directory of the 
          pipeline description and from the directory of this script
        * contains a `glob` function mapping to `glob.glob`
        * has filters to transform to JSON and YAML
    """
    
    loader = jinja2.FileSystemLoader([
        "/",
        os.path.abspath(os.path.dirname(arguments.pipeline)),
        os.path.abspath(os.path.dirname(__file__)),
    ])
       
    environment = jinja2.Environment(loader=loader, keep_trailing_newline=True)
    environment.globals.update(
        glob=lambda x: sorted(
            x[len(known_ninja_arguments.directory):] for x in 
            glob.glob(os.path.join(known_ninja_arguments.directory, x)))
    )
    environment.filters["json"] = lambda x: json.dumps(x)
    environment.filters["yaml"] = lambda x: yaml.dump(x, default_flow_style=False)
    
    return environment

def parse_pipeline(arguments, jinja_arguments, environment):
    """ Parse the Jinja+YAML pipeline description, normalize scalar items to 
        lists, and add a mapping from step ids to steps.
    """
    
    template = environment.get_template(arguments.pipeline)
    rendered = template.render(**jinja_arguments)
    pipeline = yaml.load(rendered)
    for step in pipeline["steps"]:
        for key in ["prerequisites", "targets", "recipe"]:
            if key in step and isinstance(step[key], basestring):
                step[key] = [step[key]]
    
    pipeline["steps_dictionary"] = {}
    for step in pipeline["steps"]:
        if step["id"] in pipeline["steps_dictionary"]:
            raise Exception("Duplicate step: {}".format(step["id"]))
        else:
            pipeline["steps_dictionary"][step["id"]] = step
    
    return pipeline

def render_ninja(pipeline, environment):
    """Render the Ninja file (rules, builds, and references)."""
    
    # Reconfigure the environment with the markup for second-stage templating.
    variable_string = (
        environment.variable_start_string, environment.variable_end_string)
    environment.variable_start_string = "$(("
    environment.variable_end_string = "))"
    
    fd = StringIO.StringIO()
    writer = ninja.Writer(fd)
    
    for step in pipeline.get("steps", []):
        # Parse references in prerequisites and recipe
        for member in ["prerequisites", "recipe"]:
            step[member] = [
                parse_references(pipeline, step, x, environment) 
                for x in step[member]]
        
        if step.get("phony"):
            # Phony build steps have no rule
            writer.build(step["targets"], "phony", step["prerequisites"])
        else: 
            writer.rule(step["id"], " ; ".join(step["recipe"]))
            writer.build(step["targets"], step["id"], step["prerequisites"])

    data = fd.getvalue()
    writer.close()
    
    # Restore environment
    environment.variable_start_string = variable_string[0]
    environment.variable_end_string = variable_string[1]
    
    return data

def parse_references(pipeline, current_step, data, environment):
    """Parse the references contained in data to other parts of the pipeline."""
    
    return environment.from_string(data).render(
        prerequisites=current_step["prerequisites"],
        targets=current_step["targets"],
        recipe=current_step["recipe"],
        **pipeline["steps_dictionary"])

def run_ninja(ninja_file, raw_ninja_arguments):
    """ Run Ninja using the file generated from the pipeline and the 
        command-line arguments.
    """
    
    process = subprocess.Popen(
        ["ninja", "-f", "/dev/stdin"]+raw_ninja_arguments, 
        stdin=subprocess.PIPE)
    process.communicate(ninja_file)
    
    return process.returncode

if __name__ == "__main__":
    sys.exit(main())
